// Copyright Nezametdinov E. Ildus 2025.
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// https://www.boost.org/LICENSE_1_0.txt)
//
module; // Global module fragment.
#include <vulkan/vulkan.h>

export module rose.graphics.vulkan.device;
export import rose.graphics.vulkan.kernel;

// Imports.
import std.compat;

////////////////////////////////////////////////////////////////////////////////
//
// Vulkan device.
//
////////////////////////////////////////////////////////////////////////////////

export namespace rose::graphics::vulkan {

////////////////////////////////////////////////////////////////////////////////
// Device queue family index definition.
////////////////////////////////////////////////////////////////////////////////

struct device_queue_family_index {
    uint32_t compute, graphics, presentation;
};

////////////////////////////////////////////////////////////////////////////////
// Device queue list definition.
////////////////////////////////////////////////////////////////////////////////

struct device_queue_list {
    VkQueue compute, graphics, presentation;
};

////////////////////////////////////////////////////////////////////////////////
// Device definition.
////////////////////////////////////////////////////////////////////////////////

struct device : object<VkDevice, vkDestroyDevice> {
    // Parent physical device.
    physical_device parent;

    // Index of selected queue families.
    device_queue_family_index queue_family_index;
};

////////////////////////////////////////////////////////////////////////////////
// Device parameters definition.
////////////////////////////////////////////////////////////////////////////////

struct device_parameters {
    // List of enabled extensions.
    std::span<char const* const> extensions;

    // List of enabled features.
    physical_device_features features;

    // Target surface for rendering (might be null).
    VkSurfaceKHR surface;
};

////////////////////////////////////////////////////////////////////////////////
// Initialization interface.
////////////////////////////////////////////////////////////////////////////////

auto
initialize(physical_device parent, device_parameters parameters) noexcept
    -> std::expected<device, error> {
    // Initialization fails if no physical device is specified.
    if(parent.handle == nullptr) {
        return std::unexpected{error{.line = __LINE__}};
    }

    // Initialize an empty result.
    auto result = device{.parent = parent};

    // Select queue families.
    if(auto n = uint32_t{}; true) {
        // Obtain properties of the queue families.
        auto properties_list = std::vector<VkQueueFamilyProperties>{};
        try {
            vkGetPhysicalDeviceQueueFamilyProperties(parent, &n, nullptr);
            properties_list.resize(n);
            vkGetPhysicalDeviceQueueFamilyProperties(
                parent, &n, properties_list.data());
        } catch(...) {
            return std::unexpected{error{.line = __LINE__}};
        }

        // Select a compute queue family.
        for(auto properties : properties_list) {
            if(properties.queueFlags & VK_QUEUE_COMPUTE_BIT) {
                break;
            } else {
                result.queue_family_index.compute++;
            }
        }

        if(n == result.queue_family_index.compute) {
            return std::unexpected{error{.line = __LINE__}};
        }

        // Select a graphics queue family.
        for(auto properties : properties_list) {
            if(properties.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
                break;
            } else {
                result.queue_family_index.graphics++;
            }
        }

        if(n == result.queue_family_index.graphics) {
            return std::unexpected{error{.line = __LINE__}};
        }

        // Select a presentation queue family.
        if(auto i = uint32_t{}; parameters.surface != nullptr) {
            // Obtain index of a queue which supports presentation to the target
            // surface.
            while(i != properties_list.size()) {
                auto is_supported = VkBool32{};
                if((vkGetPhysicalDeviceSurfaceSupportKHR(
                        parent, i, parameters.surface, &is_supported) ==
                    VK_SUCCESS) &&
                   is_supported) {
                    break;
                } else {
                    i++;
                }
            }

            // And save it as part of the result.
            result.queue_family_index.presentation = i;
        } else {
            result.queue_family_index.presentation =
                result.queue_family_index.graphics;
        }

        if(n == result.queue_family_index.presentation) {
            return std::unexpected{error{.line = __LINE__}};
        }
    }

    // Create a new device.
    if(true) {
        // Pack queue family indices in an array.
        auto queue_family_indices = std::array{
            result.queue_family_index.compute,
            result.queue_family_index.graphics,
            result.queue_family_index.presentation};

        // Sort the array.
        std::ranges::sort(queue_family_indices);

        // Initialize an array of device queue creation info structures.
        auto priority = 1.0f;

        VkDeviceQueueCreateInfo device_queue_create_infos[] = {
            {.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
             .queueCount = 1,
             .pQueuePriorities = &priority},
            {.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
             .queueCount = 1,
             .pQueuePriorities = &priority},
            {.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
             .queueCount = 1,
             .pQueuePriorities = &priority}};

        // Count the unique family indices.
        auto queue_family_count = uint32_t{};
        if(auto previous = uint32_t{0xFFFFFFFF}; true) {
            for(auto i : queue_family_indices) {
                if(previous == i) {
                    continue;
                }

                device_queue_create_infos[queue_family_count++]
                    .queueFamilyIndex = previous = i;
            }
        }

        // Obtain the number of requested extensions.
        auto extension_count =
            static_cast<uint32_t>(parameters.extensions.size());

        if(extension_count != parameters.extensions.size()) {
            return std::unexpected{error{.line = __LINE__}};
        }

        // Initialize device creation info.
        auto info = VkDeviceCreateInfo{
            .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            .pNext = &(parameters.features),
            .queueCreateInfoCount = queue_family_count,
            .pQueueCreateInfos = device_queue_create_infos,
            .enabledExtensionCount = extension_count,
            .ppEnabledExtensionNames = parameters.extensions.data()};

        // Create a new device.
        if(auto code = vkCreateDevice(parent, &info, nullptr, &(result.handle));
           code != VK_SUCCESS) {
            return std::unexpected{error{.line = __LINE__, .code = code}};
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////
// Query interface.
////////////////////////////////////////////////////////////////////////////////

auto
obtain_device_queue_list(device const& device) noexcept -> device_queue_list {
    // Initialize an empty result.
    auto result = device_queue_list{};

#define obtain_queue_(type) \
    vkGetDeviceQueue(device, device.queue_family_index.type, 0, &(result.type))

    // Obtain device's queues.
    obtain_queue_(compute);
    obtain_queue_(graphics);
    obtain_queue_(presentation);

#undef obtain_queue_

    return result;
}

} // namespace rose::graphics::vulkan
