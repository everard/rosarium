// Copyright Nezametdinov E. Ildus 2025.
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// https://www.boost.org/LICENSE_1_0.txt)
//
module; // Global module fragment.
#include <SDL.h>
#include <SDL_vulkan.h>
#include <vulkan/vulkan.h>

export module rose.graphics.vulkan.swapchain;
export import rose.graphics.vulkan.device;

// Imports.
import std.compat;

////////////////////////////////////////////////////////////////////////////////
//
// Vulkan surface.
//
////////////////////////////////////////////////////////////////////////////////

export namespace rose::graphics::vulkan {

////////////////////////////////////////////////////////////////////////////////
// Surface definition.
////////////////////////////////////////////////////////////////////////////////

using surface = resource<VkInstance, VkSurfaceKHR, vkDestroySurfaceKHR>;

////////////////////////////////////////////////////////////////////////////////
// Surface parameters definition.
////////////////////////////////////////////////////////////////////////////////

struct surface_parameters {
    SDL_Window* window;
};

////////////////////////////////////////////////////////////////////////////////
// Surface properties definition.
////////////////////////////////////////////////////////////////////////////////

struct surface_properties {
    // List of capabilities.
    VkSurfaceCapabilitiesKHR capabilities;

    // List of supported formats.
    std::vector<VkSurfaceFormatKHR> formats;

    // List of supported presentation modes.
    std::vector<VkPresentModeKHR> presentation_modes;
};

////////////////////////////////////////////////////////////////////////////////
// Initialization interface.
////////////////////////////////////////////////////////////////////////////////

auto
initialize(instance const& instance, surface_parameters parameters) noexcept
    -> std::expected<surface, error> {
    // Initialization fails if no window is specified.
    if(parameters.window == nullptr) {
        return std::unexpected{error{.line = __LINE__}};
    }

    // Initialize a new surface.
    auto result = surface{instance};
    if(SDL_Vulkan_CreateSurface(parameters.window, instance, &result.handle)) {
        return result;
    } else {
        return std::unexpected{error{.line = __LINE__}};
    }
}

////////////////////////////////////////////////////////////////////////////////
// Query interface.
////////////////////////////////////////////////////////////////////////////////

auto
obtain_properties(
    surface const& surface, physical_device const& device) noexcept
    -> std::expected<surface_properties, error> {
    // Properties can be obtained only from a valid surface and physical device.
    if((surface.handle == nullptr) || (device.handle == nullptr)) {
        return std::unexpected{error{.line = __LINE__}};
    }

    // Initialize an empty result.
    auto result = surface_properties{};

#define try_(expression)                                               \
    if(auto code = (expression); code != VK_SUCCESS) {                 \
        return std::unexpected{error{.line = __LINE__, .code = code}}; \
    }

    // Obtain surface's capabilities.
    try_(vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
        device, surface, &result.capabilities));

    // Obtain the list of supported formats.
    if(auto n = uint32_t{}; true) {
        try_(
            vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &n, nullptr));

        try {
            result.formats.resize(n);
        } catch(...) {
            return std::unexpected{error{.line = __LINE__}};
        }

        try_(vkGetPhysicalDeviceSurfaceFormatsKHR(
            device, surface, &n, result.formats.data()));
    }

    // Obtain the list of supported presentation modes.
    if(auto n = uint32_t{}; true) {
        try_(vkGetPhysicalDeviceSurfacePresentModesKHR(
            device, surface, &n, nullptr));

        try {
            result.presentation_modes.resize(n);
        } catch(...) {
            return std::unexpected{error{.line = __LINE__}};
        }

        try_(vkGetPhysicalDeviceSurfacePresentModesKHR(
            device, surface, &n, result.presentation_modes.data()));
    }

#undef try_

    return std::move(result);
}

} // namespace rose::graphics::vulkan

////////////////////////////////////////////////////////////////////////////////
//
// Vulkan swapchain.
//
////////////////////////////////////////////////////////////////////////////////

export namespace rose::graphics::vulkan {

////////////////////////////////////////////////////////////////////////////////
// Swapchain definition.
////////////////////////////////////////////////////////////////////////////////

using swapchain = device_resource<VkSwapchainKHR, vkDestroySwapchainKHR>;

////////////////////////////////////////////////////////////////////////////////
// Swapchain parameters definition.
////////////////////////////////////////////////////////////////////////////////

struct swapchain_parameters {
    // Surface's description.
    VkSurfaceKHR surface;
    VkSurfaceFormatKHR surface_format;
    VkSurfaceTransformFlagBitsKHR surface_transform;

    // Requested presentation mode.
    VkPresentModeKHR presentation_mode;

    // Extent and usage flags of swapchain images.
    VkExtent2D image_extent;
    VkImageUsageFlags image_usage_flags;

    // Number of images in swapchain, and number of views in multiview surface.
    uint32_t image_count;
    uint32_t image_array_layer_count;
};

////////////////////////////////////////////////////////////////////////////////
// Initialization interface.
////////////////////////////////////////////////////////////////////////////////

auto
initialize(swapchain swapchain_old, swapchain_parameters parameters) noexcept
    -> std::expected<swapchain, error> {
    // Initialization fails if old swapchain is invalid.
    if(swapchain_old.parent == nullptr) {
        return std::unexpected{error{.line = __LINE__}};
    }

    // Initialization fails if no surface is specified.
    if(parameters.surface == nullptr) {
        return std::unexpected{error{.line = __LINE__}};
    }

    // Initialize a new swapchain.
    return initialize<swapchain>(
        vkCreateSwapchainKHR, swapchain_old.parent,
        {.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
         .surface = parameters.surface,
         .minImageCount = parameters.image_count,
         .imageFormat = parameters.surface_format.format,
         .imageColorSpace = parameters.surface_format.colorSpace,
         .imageExtent = parameters.image_extent,
         .imageArrayLayers = parameters.image_array_layer_count,
         .imageUsage = parameters.image_usage_flags,
         .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE,
         .preTransform = parameters.surface_transform,
         .compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
         .presentMode = parameters.presentation_mode,
         .clipped = VK_TRUE,
         .oldSwapchain = swapchain_old.handle});
}

auto
initialize(device const& device, swapchain_parameters parameters) noexcept
    -> std::expected<swapchain, error> {
    return initialize(swapchain{device}, parameters);
}

////////////////////////////////////////////////////////////////////////////////
// Query interface.
////////////////////////////////////////////////////////////////////////////////

auto
obtain_images(swapchain const& swapchain) noexcept
    -> std::expected<std::vector<VkImage>, error> {
    // Images can be obtained only from a valid swapchain.
    if((swapchain.parent == nullptr) || (swapchain.handle == nullptr)) {
        return std::unexpected{error{.line = __LINE__}};
    }

    // Initialize an empty result.
    auto result = std::vector<VkImage>{};

#define try_(expression)                                               \
    if(auto code = (expression); code != VK_SUCCESS) {                 \
        return std::unexpected{error{.line = __LINE__, .code = code}}; \
    }

    // Obtain the list of swapchain images.
    if(auto n = uint32_t{}; true) {
        try_(vkGetSwapchainImagesKHR(
            swapchain.parent, swapchain.handle, &n, nullptr));

        try {
            result.resize(n);
        } catch(...) {
            return std::unexpected{error{.line = __LINE__}};
        }

        try_(vkGetSwapchainImagesKHR(
            swapchain.parent, swapchain.handle, &n, result.data()));
    }

#undef try_

    return std::move(result);
}

} // namespace rose::graphics::vulkan
